Before submitting this file, make sure that there are no more TODO
placeholders remaining in the file (and remove this comment too).

Perfect Numbers
---------------

Before submitting this file, make sure that there are no more TODO
placeholders remaining in the file (and remove this comment too).

Q1. Roughly how long did it take your computer to do the search? How many perfect numbers were found and what were they?
A1. it takes 7.5s, and there are 4 perfect numbers including 6, 28, 496, 8128.

Q2. Record the timing results for `findPerfects` that you observed into a table.
A2.
Line 175 TIME_OPERATION findPerfects(10000) (size =    10000) completed in    0.655 secs
Line 176 TIME_OPERATION findPerfects(20000) (size =    20000) completed in    2.089 secs
Line 177 TIME_OPERATION findPerfects(40000) (size =    40000) completed in    6.913 secs

Line 189 TIME_OPERATION findPerfects(15000) (size =    15000) completed in    1.229 secs
Line 190 TIME_OPERATION findPerfects(30000) (size =    30000) completed in    4.134 secs
Line 191 TIME_OPERATION findPerfects(60000) (size =    60000) completed in   12.877 secs
Line 192 TIME_OPERATION findPerfects(120000) (size =   120000) completed in   55.398 secs


Q3. Does it take the same amount of work to compute `isPerfect` on the number 10 as it does on the number 1000? Why or why not? Does it take the same amount of work for `findPerfects` to search the range of numbers from 1-1000 as it does to search the numbers from 1000-2000? Why or why not?
A3.
1. Yes, bacause it takes the same amount of time to compute `isPerfect` on the two different numbers.
2. No, bacause it does not take the same amount of time to compute `findPerfects` on the two different numbers, and it take the more amount of work for `findPerfects` to search the range of numbers from 1-1000 than the numbers from 1000-2000


Q4. Extrapolate from the data you gathered and make a prediction: how long will it take `findPerfects` to reach the fifth perfect number?
A4. I guess it takes about 1,250 hours for `findPerfects` to reach the fifth perfect number.

Q5. Do any of the tests still pass even with this broken function? Why or why not?
A5. No, they do not. because the present `divisorSum` is more one than the previous one after subsituting total = 0 with total = 1.

Q6. Describe the testing strategy you used for your test cases to confirm `smarterSum` is working correctly.
A6.
EXPECT_EQUAL(divisorSum(-1), smarterSum(-1));//negative integer
EXPECT_EQUAL(divisorSum(6), smarterSum(6));//perfect number
EXPECT_EQUAL(divisorSum(90000), smarterSum(90000));//ordinary square number

Q7. Record your timing results for `findPerfectsSmarter` into a table.
A7. 
Line 223 TIME_OPERATION findPerfectsSmarter(300000) (size =   300000) completed in    3.766 secs
Line 224 TIME_OPERATION findPerfectsSmarter(600000) (size =   600000) completed in    9.937 secs
Line 225 TIME_OPERATION findPerfectsSmarter(1200000) (size =  1200000) completed in   24.168 secs
Line 226 TIME_OPERATION findPerfectsSmarter(2400000) (size =  2400000) completed in   71.294 secs

Q8. Make a prediction: how long will `findPerfectsSmarter` take to reach the fifth perfect number?
A8. I guess it takes about 27 hours for `findPerfectsSmarter` to reach the fifth perfect number.

Q9. Explain how you chose your specific test cases and why they lead you to be confident `findNthPerfectEuclid` is working correctly.
A9. 
EXPECT(isPerfect(findNthPerfectEuclid(1)));
EXPECT(isPerfect(findNthPerfectEuclid(2)));
EXPECT(isPerfect(findNthPerfectEuclid(3)));
EXPECT(isPerfect(findNthPerfectEuclid(4)));

EXPECT_EQUAL(6, findNthPerfectEuclid(1));
EXPECT_EQUAL(28, findNthPerfectEuclid(2));
EXPECT_EQUAL(496, findNthPerfectEuclid(3));
EXPECT_EQUAL(8128, findNthPerfectEuclid(4));

Check findNthPerfectEuclid with 4 known perfect number, and print out "Correct (STUDENT_TEST, perfect.cpp:230) my trials of findNthPerfectEuclid"

Soundex
-------

Q10. What is the Soundex code for "Angelou"? What is the code for your own surname?
A10. A524, S500.

Q11. Before writing any code, brainstorm your plan of attack and sketch how you might decompose the work into smaller tasks. Briefly describe your decomposition strategy.
A11. 
1.remove all non-letter characters
2.encode for characters of alphabetic string
3.merge adjacent repeated numbers in the digital string
4.subsitute first number with capital letter of surname
5.delete all digits of 0 
6.ensure length of 4 places for final string by being padded with 0 or cutting off the excess part. 

Q12. Think about one or more examples of a class of names that the Soundex system might not work well for. Explain what this class of names is and why the system might incorrectly group them or mis-categorize one of the names.
A12. surname starting with a number, punctuation and space, such as "_sun", "&&boy", " girl " etc.
In the function 'header', the first letter of the parameter 'origin' may not be a letter. 

Q13. Suppose you are a software engineer working for the U.S. government. You have been tasked with implementing a system that collects names as part of the Census survey and analyzes these names using a phonetic algorithm. Your boss suggests using Soundex and notes that the algorithm is only expected to work for ASCII-encoded strings, since supporting Unicode would require extra work and time. What would your response be and why? What representational harms might result from building a system that exclusively uses Soundex and/or ASCII?
A13. Only consideration of english is ASCII encoding enough. ASCII encoding is 1 byte, and Unicode coding is usually 2 bytes.
Only using Soundex and/or ASCII will there exist garbled code problem when chinese involved .


